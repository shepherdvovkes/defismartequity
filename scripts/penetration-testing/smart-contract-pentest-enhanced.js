/**
 * üîí Enhanced Smart Contract Penetration Testing Suite
 * Tests the fixed DefimonInvestmentV2_Secured_Fixed contract
 * 
 * SECURITY IMPROVEMENTS TESTED:
 * - Enhanced reentrancy protection
 * - State locking mechanism
 * - Security event logging
 * - Improved input validation
 */

const { ethers } = require('hardhat');
const fs = require('fs');
const path = require('path');

class EnhancedSmartContractPenetrationTest {
    constructor() {
        this.contracts = {};
        this.testResults = [];
        this.vulnerabilities = [];
        this.startTime = Date.now();
    }

    /**
     * üîí Initialize test environment
     */
    async initialize() {
        console.log('üîí Initializing Enhanced Smart Contract Penetration Testing Suite...');
        
        try {
            // Get signers
            const [owner, user1, user2, user3, attacker] = await ethers.getSigners();
            this.signers = { owner, user1, user2, user3, attacker };
            
            // Deploy token contract
            const DefimonTokenV2 = await ethers.getContractFactory('DefimonTokenV2');
            this.contracts.token = await DefimonTokenV2.deploy();
            await this.contracts.token.deployed();
            
            // Deploy enhanced investment contract
            const DefimonInvestmentV2_Secured_Fixed = await ethers.getContractFactory('DefimonInvestmentV2_Secured_Fixed');
            this.contracts.investment = await DefimonInvestmentV2_Secured_Fixed.deploy(
                this.contracts.token.address,
                user1.address,
                user2.address,
                user3.address
            );
            await this.contracts.investment.deployed();
            
            // Transfer tokens to investment contract (owner has all tokens initially)
            await this.contracts.token.transferTokens(
                this.contracts.investment.address,
                ethers.utils.parseEther("1000000")
            );
            
            // Deploy reentrancy attacker contract
            const ReentrancyAttacker = await ethers.getContractFactory('ReentrancyAttacker');
            this.contracts.attacker = await ReentrancyAttacker.deploy(this.contracts.investment.address);
            await this.contracts.attacker.deployed();
            
            console.log('‚úÖ Test environment initialized');
            console.log(`Token Contract: ${this.contracts.token.address}`);
            console.log(`Investment Contract: ${this.contracts.investment.address}`);
            console.log(`Attacker Contract: ${this.contracts.attacker.address}`);
            
        } catch (error) {
            console.error('‚ùå Failed to initialize test environment:', error.message);
            throw error;
        }
    }

    /**
     * üîí Test enhanced reentrancy protection
     */
    async testEnhancedReentrancyProtection() {
        console.log('üîç Testing Enhanced Reentrancy Attack Vectors...');
        
        try {
            // Test 1: Direct reentrancy attack
            const attackAmount = ethers.utils.parseEther("1");
            
            // Fund attacker contract
            await this.signers.owner.sendTransaction({
                to: this.contracts.attacker.address,
                value: attackAmount
            });
            
            // Attempt reentrancy attack
            try {
                await this.contracts.attacker.attack(attackAmount);
                
                // Check if attack was successful
                const contractBalance = await ethers.provider.getBalance(this.contracts.investment.address);
                const attackerBalance = await ethers.provider.getBalance(this.contracts.attacker.address);
                
                if (attackerBalance.gt(attackAmount)) {
                    this.addVulnerability('CRITICAL', 'Enhanced Reentrancy Attack Successful', 
                        'Contract still vulnerable to reentrancy despite enhanced protection', 9.8);
                } else {
                    this.addTestResult('‚úÖ Enhanced reentrancy protection working', 'PASS');
                }
                
            } catch (error) {
                if (error.message.includes('reentrant call') || error.message.includes('State inconsistency')) {
                    this.addTestResult('‚úÖ Enhanced reentrancy protection working', 'PASS');
                } else {
                    this.addTestResult('‚ö†Ô∏è Unexpected error during reentrancy test', 'WARNING');
                }
            }
            
            // Test 2: State locking mechanism
            await this.testStateLockingMechanism();
            
        } catch (error) {
            this.addTestResult('‚ùå Enhanced reentrancy test failed', 'ERROR');
            console.error('Error testing enhanced reentrancy protection:', error.message);
        }
    }

    /**
     * üîí Test state locking mechanism
     */
    async testStateLockingMechanism() {
        console.log('üîç Testing State Locking Mechanism...');
        
        try {
            // Get security status
            const securityStatus = await this.contracts.investment.getSecurityStatus();
            
            if (securityStatus.isLocked) {
                this.addTestResult('‚úÖ State locking mechanism active', 'PASS');
            } else {
                this.addTestResult('‚ö†Ô∏è State locking mechanism not active', 'WARNING');
            }
            
            // Test concurrent calls (simulate)
            const promises = [];
            for (let i = 0; i < 3; i++) {
                promises.push(
                    this.contracts.investment.invest({ value: ethers.utils.parseEther("0.1") })
                        .catch(e => e.message)
                );
            }
            
            const results = await Promise.all(promises);
            const successCount = results.filter(r => !r.includes('reentrant')).length;
            
            if (successCount === 1) {
                this.addTestResult('‚úÖ State locking prevents concurrent calls', 'PASS');
            } else {
                this.addTestResult('‚ö†Ô∏è State locking may not be working correctly', 'WARNING');
            }
            
        } catch (error) {
            this.addTestResult('‚ùå State locking test failed', 'ERROR');
            console.error('Error testing state locking:', error.message);
        }
    }

    /**
     * üîí Test security event logging
     */
    async testSecurityEventLogging() {
        console.log('üîç Testing Security Event Logging...');
        
        try {
            // Make a legitimate investment to trigger security events
            const investmentAmount = ethers.utils.parseEther("0.1");
            
            const tx = await this.contracts.investment.invest({ value: investmentAmount });
            const receipt = await tx.wait();
            
            // Check for security events
            const securityEvents = receipt.logs.filter(log => {
                try {
                    const parsed = this.contracts.investment.interface.parseLog(log);
                    return parsed.name === 'SecurityEvent';
                } catch {
                    return false;
                }
            });
            
            if (securityEvents.length > 0) {
                this.addTestResult('‚úÖ Security event logging working', 'PASS');
                
                // Log security event details
                securityEvents.forEach((event, index) => {
                    try {
                        const parsed = this.contracts.investment.interface.parseLog(event);
                        console.log(`üîí Security Event ${index + 1}:`, {
                            eventType: parsed.args.eventType,
                            account: parsed.args.account,
                            timestamp: parsed.args.timestamp.toString()
                        });
                    } catch (e) {
                        console.log(`üîí Security Event ${index + 1}: Raw event`);
                    }
                });
            } else {
                this.addTestResult('‚ö†Ô∏è Security event logging not working', 'WARNING');
            }
            
        } catch (error) {
            this.addTestResult('‚ùå Security event logging test failed', 'ERROR');
            console.error('Error testing security event logging:', error.message);
        }
    }

    /**
     * üîí Test improved input validation
     */
    async testImprovedInputValidation() {
        console.log('üîç Testing Improved Input Validation...');
        
        try {
            // Test 1: Zero amount
            try {
                await this.contracts.investment.invest({ value: 0 });
                this.addVulnerability('MEDIUM', 'Zero Amount Validation Failed', 
                    'Contract accepts zero amount investments', 4.0);
            } catch (error) {
                if (error.message.includes('greater than 0')) {
                    this.addTestResult('‚úÖ Zero amount validation working', 'PASS');
                } else {
                    this.addTestResult('‚ö†Ô∏è Unexpected error for zero amount', 'WARNING');
                }
            }
            
            // Test 2: Invalid address validation
            try {
                await this.contracts.investment.setBlacklist(ethers.constants.AddressZero, true);
                this.addVulnerability('MEDIUM', 'Zero Address Validation Failed', 
                    'Contract accepts zero address for blacklist', 4.0);
            } catch (error) {
                if (error.message.includes('zero address')) {
                    this.addTestResult('‚úÖ Zero address validation working', 'PASS');
                } else {
                    this.addTestResult('‚ö†Ô∏è Unexpected error for zero address', 'WARNING');
                }
            }
            
            // Test 3: Large amount validation
            const extremelyLargeAmount = ethers.utils.parseEther("1000000"); // 1M ETH
            try {
                await this.contracts.investment.invest({ value: extremelyLargeAmount });
                this.addVulnerability('MEDIUM', 'Large Amount Validation Failed', 
                    'Contract accepts extremely large amounts', 4.0);
            } catch (error) {
                if (error.message.includes('exceeds limits')) {
                    this.addTestResult('‚úÖ Large amount validation working', 'PASS');
                } else {
                    this.addTestResult('‚ö†Ô∏è Unexpected error for large amount', 'WARNING');
                }
            }
            
        } catch (error) {
            this.addTestResult('‚ùå Input validation test failed', 'ERROR');
            console.error('Error testing input validation:', error.message);
        }
    }

    /**
     * üîí Test access control enhancements
     */
    async testAccessControlEnhancements() {
        console.log('üîç Testing Access Control Enhancements...');
        
        try {
            // Test emergency functions
            try {
                await this.contracts.investment.connect(this.signers.user1).emergencyPause();
                this.addVulnerability('HIGH', 'Emergency Function Access Control Failed', 
                    'Non-emergency role can call emergency functions', 7.0);
            } catch (error) {
                if (error.message.includes('emergency role')) {
                    this.addTestResult('‚úÖ Emergency function access control working', 'PASS');
                } else {
                    this.addTestResult('‚ö†Ô∏è Unexpected error for emergency function', 'WARNING');
                }
            }
            
            // Test price update access control
            try {
                await this.contracts.investment.connect(this.signers.user1).updateEthUsdPrice(2500);
                this.addVulnerability('HIGH', 'Price Update Access Control Failed', 
                    'Non-price-updater role can update prices', 7.0);
            } catch (error) {
                if (error.message.includes('price updater')) {
                    this.addTestResult('‚úÖ Price update access control working', 'PASS');
                } else {
                    this.addTestResult('‚ö†Ô∏è Unexpected error for price update', 'WARNING');
                }
            }
            
            // Test multisig access control
            try {
                await this.contracts.investment.connect(this.signers.user1).approveLargeInvestment(
                    ethers.utils.hexZeroPad("0x1", 32)
                );
                this.addVulnerability('HIGH', 'Multisig Access Control Failed', 
                    'Non-multisig role can approve investments', 7.0);
            } catch (error) {
                if (error.message.includes('multisig role')) {
                    this.addTestResult('‚úÖ Multisig access control working', 'PASS');
                } else {
                    this.addTestResult('‚ö†Ô∏è Unexpected error for multisig function', 'WARNING');
                }
            }
            
        } catch (error) {
            this.addTestResult('‚ùå Access control test failed', 'ERROR');
            console.error('Error testing access control:', error.message);
        }
    }

    /**
     * üîí Test price manipulation protection
     */
    async testPriceManipulationProtection() {
        console.log('üîç Testing Price Manipulation Protection...');
        
        try {
            // Test 1: Price cooldown
            try {
                await this.contracts.investment.updateEthUsdPrice(2500);
                await this.contracts.investment.updateEthUsdPrice(2600);
                this.addVulnerability('MEDIUM', 'Price Cooldown Protection Failed', 
                    'Price can be updated too frequently', 4.0);
            } catch (error) {
                if (error.message.includes('Cooldown not met')) {
                    this.addTestResult('‚úÖ Price cooldown protection working', 'PASS');
                } else {
                    this.addTestResult('‚ö†Ô∏è Unexpected error for price cooldown', 'WARNING');
                }
            }
            
            // Test 2: Price change percentage limit
            try {
                // Wait for cooldown
                await ethers.provider.send("evm_increaseTime", [3600]); // 1 hour
                await ethers.provider.send("evm_mine");
                
                // Try to set extremely high price
                await this.contracts.investment.updateEthUsdPrice(1000000); // 1M USD
                this.addVulnerability('MEDIUM', 'Price Change Limit Failed', 
                    'Extreme price changes allowed', 4.0);
            } catch (error) {
                if (error.message.includes('too high')) {
                    this.addTestResult('‚úÖ Price change limit protection working', 'PASS');
                } else {
                    this.addTestResult('‚ö†Ô∏è Unexpected error for price change limit', 'WARNING');
                }
            }
            
        } catch (error) {
            this.addTestResult('‚ùå Price manipulation protection test failed', 'ERROR');
            console.error('Error testing price manipulation protection:', error.message);
        }
    }

    /**
     * üîí Test blacklist protection enhancements
     */
    async testBlacklistProtectionEnhancements() {
        console.log('üîç Testing Blacklist Protection Enhancements...');
        
        try {
            // Test 1: Blacklist signers
            try {
                await this.contracts.investment.setBlacklist(this.signers.user1.address, true);
                this.addVulnerability('MEDIUM', 'Signer Blacklist Protection Failed', 
                    'Signers can be blacklisted', 4.0);
            } catch (error) {
                if (error.message.includes('Cannot blacklist signers')) {
                    this.addTestResult('‚úÖ Signer blacklist protection working', 'PASS');
                } else {
                    this.addTestResult('‚ö†Ô∏è Unexpected error for signer blacklist', 'WARNING');
                }
            }
            
            // Test 2: Blacklist regular user
            try {
                await this.contracts.investment.setBlacklist(this.signers.user1.address, true);
                this.addTestResult('‚úÖ Regular user blacklist working', 'PASS');
                
                // Test that blacklisted user cannot invest
                try {
                    await this.contracts.investment.connect(this.signers.user1).invest({ 
                        value: ethers.utils.parseEther("0.1") 
                    });
                    this.addVulnerability('HIGH', 'Blacklist Enforcement Failed', 
                        'Blacklisted user can still invest', 7.0);
                } catch (error) {
                    if (error.message.includes('blacklisted')) {
                        this.addTestResult('‚úÖ Blacklist enforcement working', 'PASS');
                    } else {
                        this.addTestResult('‚ö†Ô∏è Unexpected error for blacklisted user', 'WARNING');
                    }
                }
                
            } catch (error) {
                this.addTestResult('‚ùå Regular user blacklist failed', 'ERROR');
            }
            
        } catch (error) {
            this.addTestResult('‚ùå Blacklist protection test failed', 'ERROR');
            console.error('Error testing blacklist protection:', error.message);
        }
    }

    /**
     * üîí Run comprehensive security tests
     */
    async runComprehensiveTests() {
        console.log('üöÄ Starting Enhanced Comprehensive Penetration Testing...\n');
        
        try {
            // Initialize test environment
            await this.initialize();
            
            // Run all security tests
            await this.testEnhancedReentrancyProtection();
            await this.testStateLockingMechanism();
            await this.testSecurityEventLogging();
            await this.testImprovedInputValidation();
            await this.testAccessControlEnhancements();
            await this.testPriceManipulationProtection();
            await this.testBlacklistProtectionEnhancements();
            
            // Generate comprehensive report
            this.generateReport();
            
        } catch (error) {
            console.error('‚ùå Enhanced penetration testing failed:', error.message);
            throw error;
        }
    }

    /**
     * üîí Add test result
     */
    addTestResult(message, status) {
        this.testResults.push({ message, status, timestamp: Date.now() });
        console.log(`${status === 'PASS' ? '‚úÖ' : status === 'WARNING' ? '‚ö†Ô∏è' : '‚ùå'} ${message}`);
    }

    /**
     * üîí Add vulnerability
     */
    addVulnerability(severity, title, description, cvss) {
        this.vulnerabilities.push({
            severity,
            title,
            description,
            cvss,
            timestamp: Date.now()
        });
        console.log(`üö® ${severity}: ${title} (CVSS: ${cvss}/10)`);
    }

    /**
     * üîí Generate comprehensive security report
     */
    generateReport() {
        console.log('\nüìä ENHANCED PENETRATION TESTING REPORT');
        console.log('='.repeat(50));
        
        // Calculate risk score
        const totalVulnerabilities = this.vulnerabilities.length;
        const criticalCount = this.vulnerabilities.filter(v => v.severity === 'CRITICAL').length;
        const highCount = this.vulnerabilities.filter(v => v.severity === 'HIGH').length;
        const mediumCount = this.vulnerabilities.filter(v => v.severity === 'MEDIUM').length;
        
        let riskScore = 10;
        riskScore -= criticalCount * 3;
        riskScore -= highCount * 2;
        riskScore -= mediumCount * 1;
        riskScore = Math.max(1, riskScore);
        
        // Display vulnerabilities
        if (totalVulnerabilities > 0) {
            console.log(`üö® Found ${totalVulnerabilities} vulnerabilities:\n`);
            
            this.vulnerabilities.forEach((vuln, index) => {
                console.log(`${index + 1}. ${vuln.severity}: ${vuln.title}`);
                console.log(`   CVSS: ${vuln.cvss}/10`);
                console.log(`   Impact: ${vuln.description}\n`);
            });
        } else {
            console.log('‚úÖ No vulnerabilities found!');
        }
        
        // Display test results summary
        const passCount = this.testResults.filter(r => r.status === 'PASS').length;
        const warningCount = this.testResults.filter(r => r.status === 'WARNING').length;
        const errorCount = this.testResults.filter(r => r.status === 'ERROR').length;
        
        console.log(`üìà Test Results Summary:`);
        console.log(`   ‚úÖ PASS: ${passCount}`);
        console.log(`   ‚ö†Ô∏è WARNING: ${warningCount}`);
        console.log(`   ‚ùå ERROR: ${errorCount}`);
        
        // Display risk assessment
        console.log(`\nüìä Overall Risk Score: ${riskScore}/10`);
        
        if (riskScore <= 2) {
            console.log('üü¢ Risk Level: LOW - Excellent security posture');
        } else if (riskScore <= 4) {
            console.log('üü° Risk Level: MEDIUM - Good security with minor issues');
        } else if (riskScore <= 6) {
            console.log('üü† Risk Level: HIGH - Significant security concerns');
        } else {
            console.log('üî¥ Risk Level: CRITICAL - Immediate action required');
        }
        
        // Save detailed report
        this.saveDetailedReport();
    }

    /**
     * üîí Save detailed report to file
     */
    saveDetailedReport() {
        const report = {
            timestamp: new Date().toISOString(),
            testResults: this.testResults,
            vulnerabilities: this.vulnerabilities,
            summary: {
                totalTests: this.testResults.length,
                passedTests: this.testResults.filter(r => r.status === 'PASS').length,
                warnings: this.testResults.filter(r => r.status === 'WARNING').length,
                errors: this.testResults.filter(r => r.status === 'ERROR').length,
                totalVulnerabilities: this.vulnerabilities.length,
                criticalVulnerabilities: this.vulnerabilities.filter(v => v.severity === 'CRITICAL').length,
                highVulnerabilities: this.vulnerabilities.filter(v => v.severity === 'HIGH').length,
                mediumVulnerabilities: this.vulnerabilities.filter(v => v.severity === 'MEDIUM').length
            }
        };
        
        const reportPath = path.join(__dirname, '../../reports/enhanced-pentest-report.json');
        fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
        
        console.log(`\nüìÅ Detailed report saved to: ${reportPath}`);
    }
}

// üîí Main execution
async function main() {
    try {
        const pentest = new EnhancedSmartContractPenetrationTest();
        await pentest.runComprehensiveTests();
        
        console.log('\nüéØ Enhanced penetration testing completed successfully');
        
    } catch (error) {
        console.error('‚ùå Enhanced penetration testing failed:', error.message);
        process.exit(1);
    }
}

// Run if called directly
if (require.main === module) {
    main();
}

module.exports = EnhancedSmartContractPenetrationTest;
