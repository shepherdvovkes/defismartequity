const { ethers } = require("hardhat");
const { expect } = require("chai");

/**
 * DEFIMON Smart Contract Penetration Testing Suite
 * Professional-grade security testing for DefimonInvestmentV2_Secured contract
 */

class SmartContractPenetrationTest {
    constructor() {
        this.contracts = {};
        this.attackResults = [];
        this.vulnerabilities = [];
        this.testWallets = [];
    }

    async initialize() {
        console.log("üîí Initializing Smart Contract Penetration Testing Suite...");
        
        // Deploy test contracts
        const [owner, attacker, investor1, investor2, investor3] = await ethers.getSigners();
        
        // Deploy token contract
        const DefimonTokenV2 = await ethers.getContractFactory("DefimonTokenV2");
        this.contracts.token = await DefimonTokenV2.deploy();
        await this.contracts.token.deployed();
        
        // Deploy investment contract
        const DefimonInvestmentV2_Secured = await ethers.getContractFactory("DefimonInvestmentV2_Secured");
        this.contracts.investment = await DefimonInvestmentV2_Secured.deploy(
            this.contracts.token.address,
            investor1.address,
            investor2.address,
            investor3.address
        );
        await this.contracts.investment.deployed();
        
        // Setup test wallets
        this.testWallets = [owner, attacker, investor1, investor2, investor3];
        
        // Transfer tokens to investment contract (owner has all tokens initially)
        await this.contracts.token.transferTokens(
            this.contracts.investment.address, 
            ethers.utils.parseEther("1000000")
        );
        
        console.log("‚úÖ Test environment initialized");
        console.log(`Token Contract: ${this.contracts.token.address}`);
        console.log(`Investment Contract: ${this.contracts.investment.address}`);
    }

    async runAllTests() {
        console.log("\nüöÄ Starting Comprehensive Penetration Testing...\n");
        
        await this.testReentrancyAttacks();
        await this.testAccessControlBypass();
        await this.testPriceManipulation();
        await this.testMultisigVulnerabilities();
        await this.testTimelockBypass();
        await this.testIntegerOverflow();
        await this.testBlacklistManipulation();
        await this.testEmergencyFunctions();
        await this.testEdgeCases();
        
        this.generateReport();
    }

    async testReentrancyAttacks() {
        console.log("üîç Testing Reentrancy Attack Vectors...");
        
        try {
            // Test 1: Reentrancy during investment
            const attackerContract = await this.deployReentrancyAttacker();
            
            // Attempt reentrancy attack
            const attackTx = await attackerContract.attack({
                value: ethers.utils.parseEther("1")
            });
            
            // Check if attack was successful
            const contractBalance = await ethers.provider.getBalance(this.contracts.investment.address);
            const attackerBalance = await this.contracts.token.balanceOf(attackerContract.address);
            
            if (attackerBalance.gt(ethers.utils.parseEther("100"))) {
                this.vulnerabilities.push({
                    severity: "CRITICAL",
                    title: "Reentrancy Vulnerability in Investment Function",
                    description: "Contract vulnerable to reentrancy attacks during investment",
                    impact: "Attacker can drain contract funds",
                    cve: "CVE-2024-DEFIMON-001",
                    cvss: 9.8
                });
            }
            
        } catch (error) {
            console.log("‚úÖ Reentrancy protection working");
        }
    }

    async testAccessControlBypass() {
        console.log("üîç Testing Access Control Bypass...");
        
        const [owner, attacker] = this.testWallets;
        
        try {
            // Test emergency functions access
            await this.contracts.investment.connect(attacker).emergencyPause();
            this.vulnerabilities.push({
                severity: "HIGH",
                title: "Access Control Bypass in Emergency Functions",
                description: "Unauthorized access to emergency functions",
                impact: "Attacker can pause contract operations",
                cve: "CVE-2024-DEFIMON-002",
                cvss: 8.5
            });
        } catch (error) {
            console.log("‚úÖ Access control working for emergency functions");
        }
        
        try {
            // Test price update access
            await this.contracts.investment.connect(attacker).updateEthUsdPrice(1000);
            this.vulnerabilities.push({
                severity: "HIGH",
                title: "Access Control Bypass in Price Updates",
                description: "Unauthorized price manipulation",
                impact: "Attacker can manipulate exchange rates",
                cve: "CVE-2024-DEFIMON-003",
                cvss: 8.0
            });
        } catch (error) {
            console.log("‚úÖ Access control working for price updates");
        }
    }

    async testPriceManipulation() {
        console.log("üîç Testing Price Manipulation Attacks...");
        
        const [owner, attacker] = this.testWallets;
        
        try {
            // Test extreme price changes
            await this.contracts.investment.connect(owner).updateEthUsdPrice(1000000); // $10,000 per ETH
            
            // Check if price validation is working
            const priceInfo = await this.contracts.investment.getPriceInfo();
            
            if (priceInfo.currentPrice.eq(1000000)) {
                this.vulnerabilities.push({
                    severity: "MEDIUM",
                    title: "Insufficient Price Validation",
                    description: "Price can be set to extreme values",
                    impact: "Potential for economic manipulation",
                    cve: "CVE-2024-DEFIMON-004",
                    cvss: 6.5
                });
            }
        } catch (error) {
            console.log("‚úÖ Price validation working");
        }
    }

    async testMultisigVulnerabilities() {
        console.log("üîç Testing Multisig Vulnerabilities...");
        
        const [owner, attacker, signer1, signer2, signer3] = this.testWallets;
        
        try {
            // Test if attacker can approve large investments
            const largeInvestmentTx = await this.contracts.investment.connect(attacker).requestLargeInvestment(
                "Test investment",
                { value: ethers.utils.parseEther("1000") }
            );
            
            // Try to approve as attacker
            await this.contracts.investment.connect(attacker).approveLargeInvestment(
                ethers.utils.id("test")
            );
            
            this.vulnerabilities.push({
                severity: "HIGH",
                title: "Multisig Approval Bypass",
                description: "Unauthorized multisig approval",
                impact: "Attacker can approve large investments",
                cve: "CVE-2024-DEFIMON-005",
                cvss: 8.0
            });
        } catch (error) {
            console.log("‚úÖ Multisig protection working");
        }
    }

    async testTimelockBypass() {
        console.log("üîç Testing Timelock Bypass...");
        
        // This would require time manipulation in Hardhat
        // For real testing, would need fork testing
        console.log("‚è∞ Timelock testing requires fork testing environment");
    }

    async testIntegerOverflow() {
        console.log("üîç Testing Integer Overflow/Underflow...");
        
        try {
            // Test with extremely large values
            const maxUint256 = ethers.constants.MaxUint256;
            
            // Test ethToUsd with large values
            const result = await this.contracts.investment.ethToUsd(maxUint256);
            
            if (result.eq(0) || result.lt(maxUint256)) {
                this.vulnerabilities.push({
                    severity: "MEDIUM",
                    title: "Potential Integer Overflow in Price Conversion",
                    description: "Large ETH amounts may cause overflow",
                    impact: "Incorrect price calculations",
                    cve: "CVE-2024-DEFIMON-006",
                    cvss: 5.5
                });
            }
        } catch (error) {
            console.log("‚úÖ Integer overflow protection working");
        }
    }

    async testBlacklistManipulation() {
        console.log("üîç Testing Blacklist Manipulation...");
        
        const [owner, attacker] = this.testWallets;
        
        try {
            // Test if attacker can modify blacklist
            await this.contracts.investment.connect(attacker).setBlacklist(attacker.address, true);
            
            this.vulnerabilities.push({
                severity: "HIGH",
                title: "Blacklist Manipulation",
                description: "Unauthorized blacklist modification",
                impact: "Attacker can control who can invest",
                cve: "CVE-2024-DEFIMON-007",
                cvss: 7.5
            });
        } catch (error) {
            console.log("‚úÖ Blacklist protection working");
        }
    }

    async testEmergencyFunctions() {
        console.log("üîç Testing Emergency Function Vulnerabilities...");
        
        const [owner, attacker] = this.testWallets;
        
        try {
            // Test emergency withdrawal access
            await this.contracts.investment.connect(attacker).emergencyWithdraw(attacker.address);
            
            this.vulnerabilities.push({
                severity: "CRITICAL",
                title: "Emergency Function Access Bypass",
                description: "Unauthorized emergency fund withdrawal",
                impact: "Attacker can drain contract funds",
                cve: "CVE-2024-DEFIMON-008",
                cvss: 9.5
            });
        } catch (error) {
            console.log("‚úÖ Emergency function protection working");
        }
    }

    async testEdgeCases() {
        console.log("üîç Testing Edge Cases...");
        
        // Test with zero addresses
        try {
            await this.contracts.investment.invest({ value: 0 });
            this.vulnerabilities.push({
                severity: "LOW",
                title: "Zero Value Investment Allowed",
                description: "Contract accepts zero ETH investments",
                impact: "Waste of gas and potential DoS",
                cve: "CVE-2024-DEFIMON-009",
                cvss: 3.5
            });
        } catch (error) {
            console.log("‚úÖ Zero value protection working");
        }
        
        // Test with invalid addresses
        try {
            await this.contracts.investment.setBlacklist(ethers.constants.AddressZero, true);
            this.vulnerabilities.push({
                severity: "MEDIUM",
                title: "Zero Address Blacklist",
                description: "Contract allows blacklisting zero address",
                impact: "Potential for contract malfunction",
                cve: "CVE-2024-DEFIMON-010",
                cvss: 4.5
            });
        } catch (error) {
            console.log("‚úÖ Zero address protection working");
        }
    }

    async deployReentrancyAttacker() {
        const ReentrancyAttacker = await ethers.getContractFactory("ReentrancyAttacker");
        return await ReentrancyAttacker.deploy(this.contracts.investment.address);
    }

    generateReport() {
        console.log("\nüìä PENETRATION TESTING REPORT");
        console.log("=" * 50);
        
        if (this.vulnerabilities.length === 0) {
            console.log("‚úÖ No vulnerabilities found!");
        } else {
            console.log(`üö® Found ${this.vulnerabilities.length} vulnerabilities:\n`);
            
            this.vulnerabilities.forEach((vuln, index) => {
                console.log(`${index + 1}. ${vuln.severity}: ${vuln.title}`);
                console.log(`   CVSS: ${vuln.cvss}/10`);
                console.log(`   CVE: ${vuln.cve}`);
                console.log(`   Impact: ${vuln.impact}`);
                console.log(`   Description: ${vuln.description}\n`);
            });
        }
        
        // Calculate risk score
        const totalRisk = this.vulnerabilities.reduce((sum, vuln) => sum + vuln.cvss, 0);
        const averageRisk = this.vulnerabilities.length > 0 ? totalRisk / this.vulnerabilities.length : 0;
        
        console.log(`üìà Overall Risk Score: ${averageRisk.toFixed(1)}/10`);
        
        if (averageRisk >= 8.0) {
            console.log("üö® CRITICAL: Immediate action required!");
        } else if (averageRisk >= 6.0) {
            console.log("‚ö†Ô∏è  HIGH: Prompt remediation needed");
        } else if (averageRisk >= 4.0) {
            console.log("üî∂ MEDIUM: Address within reasonable timeframe");
        } else if (averageRisk >= 2.0) {
            console.log("üî∑ LOW: Low priority, monitor closely");
        } else {
            console.log("‚úÖ EXCELLENT: Strong security posture");
        }
    }
}

// Export for use in other scripts
module.exports = { SmartContractPenetrationTest };

// Run if called directly
if (require.main === module) {
    async function main() {
        const pentest = new SmartContractPenetrationTest();
        await pentest.initialize();
        await pentest.runAllTests();
    }
    
    main()
        .then(() => process.exit(0))
        .catch((error) => {
            console.error(error);
            process.exit(1);
        });
}
