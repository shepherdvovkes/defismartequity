const axios = require('axios');
const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

/**
 * DEFIMON Frontend Penetration Testing Suite
 * Professional-grade security testing for Next.js application
 */

class FrontendPenetrationTest {
    constructor() {
        this.baseUrl = 'http://localhost:3000';
        this.vulnerabilities = [];
        this.testResults = [];
        this.securityHeaders = {};
    }

    async initialize() {
        console.log("üåê Initializing Frontend Penetration Testing Suite...");
        
        // Check if application is running
        try {
            const response = await axios.get(this.baseUrl, { timeout: 5000 });
            console.log("‚úÖ Application is running");
        } catch (error) {
            console.log("‚ùå Application not running. Please start with: npm run dev");
            process.exit(1);
        }
    }

    async runAllTests() {
        console.log("\nüöÄ Starting Frontend Penetration Testing...\n");
        
        await this.testSecurityHeaders();
        await this.testXSSVulnerabilities();
        await this.testCSRFVulnerabilities();
        await this.testAuthenticationBypass();
        await this.testInjectionAttacks();
        await this.testSensitiveDataExposure();
        await this.testDependencyVulnerabilities();
        await this.testAPIEndpoints();
        await this.testInputValidation();
        await this.testErrorHandling();
        
        this.generateReport();
    }

    async testSecurityHeaders() {
        console.log("üîç Testing Security Headers...");
        
        try {
            const response = await axios.get(this.baseUrl);
            const headers = response.headers;
            
            const requiredHeaders = {
                'X-Frame-Options': 'Clickjacking protection',
                'X-Content-Type-Options': 'MIME type sniffing protection',
                'X-XSS-Protection': 'XSS protection',
                'Strict-Transport-Security': 'HTTPS enforcement',
                'Content-Security-Policy': 'Content security policy',
                'Referrer-Policy': 'Referrer information control'
            };
            
            Object.entries(requiredHeaders).forEach(([header, description]) => {
                if (!headers[header.toLowerCase()]) {
                    this.vulnerabilities.push({
                        severity: "MEDIUM",
                        title: `Missing Security Header: ${header}`,
                        description: `Security header ${header} is not set`,
                        impact: `Reduced protection against ${description.toLowerCase()}`,
                        cve: "CVE-2024-DEFIMON-101",
                        cvss: 4.0
                    });
                }
            });
            
            console.log("‚úÖ Security headers test completed");
        } catch (error) {
            console.log("‚ùå Error testing security headers:", error.message);
        }
    }

    async testXSSVulnerabilities() {
        console.log("üîç Testing XSS Vulnerabilities...");
        
        const xssPayloads = [
            '<script>alert("XSS")</script>',
            'javascript:alert("XSS")',
            '<img src="x" onerror="alert(\'XSS\')">',
            '<svg onload="alert(\'XSS\')">',
            '"><script>alert("XSS")</script>'
        ];
        
        // Test search functionality if it exists
        try {
            for (const payload of xssPayloads) {
                const response = await axios.get(`${this.baseUrl}/api/search?q=${encodeURIComponent(payload)}`);
                
                if (response.data.includes(payload) || response.data.includes('<script>')) {
                    this.vulnerabilities.push({
                        severity: "HIGH",
                        title: "Cross-Site Scripting (XSS) Vulnerability",
                        description: `XSS payload reflected in response: ${payload}`,
                        impact: "Attacker can execute arbitrary JavaScript in user's browser",
                        cve: "CVE-2024-DEFIMON-102",
                        cvss: 8.0
                    });
                    break;
                }
            }
            
            console.log("‚úÖ XSS testing completed");
        } catch (error) {
            // Search endpoint might not exist, which is fine
            console.log("‚ÑπÔ∏è  Search endpoint not found, skipping XSS test");
        }
    }

    async testCSRFVulnerabilities() {
        console.log("üîç Testing CSRF Vulnerabilities...");
        
        // Test if forms have CSRF tokens
        try {
            const response = await axios.get(this.baseUrl);
            const html = response.data;
            
            // Check for common form patterns without CSRF protection
            if (html.includes('<form') && !html.includes('csrf') && !html.includes('_token')) {
                this.vulnerabilities.push({
                    severity: "MEDIUM",
                    title: "Potential CSRF Vulnerability",
                    description: "Forms found without apparent CSRF protection",
                    impact: "Attacker can perform actions on behalf of authenticated users",
                    cve: "CVE-2024-DEFIMON-103",
                    cvss: 6.5
                });
            }
            
            console.log("‚úÖ CSRF testing completed");
        } catch (error) {
            console.log("‚ùå Error testing CSRF:", error.message);
        }
    }

    async testAuthenticationBypass() {
        console.log("üîç Testing Authentication Bypass...");
        
        // Test protected routes without authentication
        const protectedRoutes = [
            '/admin',
            '/dashboard',
            '/profile',
            '/api/admin',
            '/api/user'
        ];
        
        for (const route of protectedRoutes) {
            try {
                const response = await axios.get(`${this.baseUrl}${route}`);
                
                if (response.status === 200) {
                    this.vulnerabilities.push({
                        severity: "CRITICAL",
                        title: "Authentication Bypass Vulnerability",
                        description: `Protected route ${route} accessible without authentication`,
                        impact: "Unauthorized access to sensitive functionality",
                        cve: "CVE-2024-DEFIMON-104",
                        cvss: 9.0
                    });
                }
            } catch (error) {
                if (error.response && error.response.status === 401) {
                    console.log(`‚úÖ ${route} properly protected`);
                }
            }
        }
        
        console.log("‚úÖ Authentication bypass testing completed");
    }

    async testInjectionAttacks() {
        console.log("üîç Testing Injection Attacks...");
        
        const injectionPayloads = {
            sql: ["' OR '1'='1", "'; DROP TABLE users; --", "1' UNION SELECT * FROM users --"],
            nosql: ['{"$gt": ""}', '{"$where": "1==1"}', '{"$ne": null}'],
            command: ['; ls -la', '| cat /etc/passwd', '&& rm -rf /']
        };
        
        // Test for potential injection points
        try {
            const response = await axios.get(this.baseUrl);
            const html = response.data;
            
            // Check for potential SQL injection in forms
            if (html.includes('input') && html.includes('name=')) {
                this.vulnerabilities.push({
                    severity: "MEDIUM",
                    title: "Potential Injection Vulnerability",
                    description: "Input fields found without apparent input validation",
                    impact: "Risk of SQL, NoSQL, or command injection",
                    cve: "CVE-2024-DEFIMON-105",
                    cvss: 5.5
                });
            }
            
            console.log("‚úÖ Injection testing completed");
        } catch (error) {
            console.log("‚ùå Error testing injection:", error.message);
        }
    }

    async testSensitiveDataExposure() {
        console.log("üîç Testing Sensitive Data Exposure...");
        
        try {
            const response = await axios.get(this.baseUrl);
            const html = response.data;
            
            // Check for sensitive information in HTML
            const sensitivePatterns = [
                /api[_-]?key/i,
                /secret/i,
                /password/i,
                /token/i,
                /private[_-]?key/i
            ];
            
            for (const pattern of sensitivePatterns) {
                if (pattern.test(html)) {
                    this.vulnerabilities.push({
                        severity: "HIGH",
                        title: "Sensitive Data Exposure",
                        description: "Potential sensitive information found in HTML source",
                        impact: "Exposure of API keys, secrets, or other sensitive data",
                        cve: "CVE-2024-DEFIMON-106",
                        cvss: 7.5
                    });
                    break;
                }
            }
            
            console.log("‚úÖ Sensitive data exposure testing completed");
        } catch (error) {
            console.log("‚ùå Error testing sensitive data exposure:", error.message);
        }
    }

    async testDependencyVulnerabilities() {
        console.log("üîç Testing Dependency Vulnerabilities...");
        
        try {
            // Run npm audit
            const auditResult = execSync('npm audit --json', { encoding: 'utf8' });
            const auditData = JSON.parse(auditResult);
            
            if (auditData.metadata && auditData.metadata.vulnerabilities) {
                const vulns = auditData.metadata.vulnerabilities;
                
                Object.entries(vulns).forEach(([severity, count]) => {
                    if (count > 0) {
                        this.vulnerabilities.push({
                            severity: severity.toUpperCase(),
                            title: `Dependency Vulnerability: ${severity}`,
                            description: `${count} ${severity} vulnerabilities found in dependencies`,
                            impact: "Potential security vulnerabilities in third-party packages",
                            cve: "CVE-2024-DEFIMON-107",
                            cvss: this.getCVSSForSeverity(severity)
                        });
                    }
                });
            }
            
            console.log("‚úÖ Dependency vulnerability testing completed");
        } catch (error) {
            console.log("‚ùå Error testing dependencies:", error.message);
        }
    }

    async testAPIEndpoints() {
        console.log("üîç Testing API Endpoints...");
        
        const apiEndpoints = [
            '/api/users',
            '/api/transactions',
            '/api/balance',
            '/api/invest',
            '/api/withdraw'
        ];
        
        for (const endpoint of apiEndpoints) {
            try {
                const response = await axios.get(`${this.baseUrl}${endpoint}`);
                
                // Check if endpoint returns sensitive data without authentication
                if (response.status === 200 && response.data) {
                    this.vulnerabilities.push({
                        severity: "MEDIUM",
                        title: "API Endpoint Information Disclosure",
                        description: `API endpoint ${endpoint} accessible without authentication`,
                        impact: "Potential exposure of sensitive business logic or data",
                        cve: "CVE-2024-DEFIMON-108",
                        cvss: 5.0
                    });
                }
            } catch (error) {
                // Endpoint might not exist or be properly protected
                console.log(`‚ÑπÔ∏è  ${endpoint} not accessible or properly protected`);
            }
        }
        
        console.log("‚úÖ API endpoint testing completed");
    }

    async testInputValidation() {
        console.log("üîç Testing Input Validation...");
        
        const maliciousInputs = [
            '<script>alert("test")</script>',
            'javascript:void(0)',
            'data:text/html,<script>alert("test")</script>',
            'vbscript:msgbox("test")',
            'onload=alert("test")'
        ];
        
        // Test form inputs if they exist
        try {
            const response = await axios.get(this.baseUrl);
            const html = response.data;
            
            if (html.includes('<form')) {
                this.vulnerabilities.push({
                    severity: "LOW",
                    title: "Input Validation Testing Required",
                    description: "Forms found - manual testing of input validation recommended",
                    impact: "Potential for various injection attacks",
                    cve: "CVE-2024-DEFIMON-109",
                    cvss: 3.0
                });
            }
            
            console.log("‚úÖ Input validation testing completed");
        } catch (error) {
            console.log("‚ùå Error testing input validation:", error.message);
        }
    }

    async testErrorHandling() {
        console.log("üîç Testing Error Handling...");
        
        try {
            // Test for information disclosure in errors
            const response = await axios.get(`${this.baseUrl}/nonexistent-route`);
            
            if (response.status === 404) {
                const errorPage = response.data;
                
                // Check for sensitive information in error pages
                if (errorPage.includes('stack trace') || errorPage.includes('error details')) {
                    this.vulnerabilities.push({
                        severity: "MEDIUM",
                        title: "Information Disclosure in Error Handling",
                        description: "Error pages reveal sensitive information",
                        impact: "Exposure of internal system details",
                        cve: "CVE-2024-DEFIMON-110",
                        cvss: 4.5
                    });
                }
            }
            
            console.log("‚úÖ Error handling testing completed");
        } catch (error) {
            if (error.response && error.response.status === 404) {
                console.log("‚úÖ 404 errors properly handled");
            }
        }
    }

    getCVSSForSeverity(severity) {
        const cvssMap = {
            'critical': 9.0,
            'high': 7.0,
            'moderate': 5.0,
            'low': 3.0
        };
        return cvssMap[severity.toLowerCase()] || 5.0;
    }

    generateReport() {
        console.log("\nüìä FRONTEND PENETRATION TESTING REPORT");
        console.log("=" * 50);
        
        if (this.vulnerabilities.length === 0) {
            console.log("‚úÖ No vulnerabilities found!");
        } else {
            console.log(`üö® Found ${this.vulnerabilities.length} vulnerabilities:\n`);
            
            this.vulnerabilities.forEach((vuln, index) => {
                console.log(`${index + 1}. ${vuln.severity}: ${vuln.title}`);
                console.log(`   CVSS: ${vuln.cvss}/10`);
                console.log(`   CVE: ${vuln.cve}`);
                console.log(`   Impact: ${vuln.impact}`);
                console.log(`   Description: ${vuln.description}\n`);
            });
        }
        
        // Calculate risk score
        const totalRisk = this.vulnerabilities.reduce((sum, vuln) => sum + vuln.cvss, 0);
        const averageRisk = this.vulnerabilities.length > 0 ? totalRisk / this.vulnerabilities.length : 0;
        
        console.log(`üìà Overall Risk Score: ${averageRisk.toFixed(1)}/10`);
        
        if (averageRisk >= 8.0) {
            console.log("üö® CRITICAL: Immediate action required!");
        } else if (averageRisk >= 6.0) {
            console.log("‚ö†Ô∏è  HIGH: Prompt remediation needed");
        } else if (averageRisk >= 4.0) {
            console.log("üî∂ MEDIUM: Address within reasonable timeframe");
        } else if (averageRisk >= 2.0) {
            console.log("üî∑ LOW: Low priority, monitor closely");
        } else {
            console.log("‚úÖ EXCELLENT: Strong security posture");
        }
    }
}

// Export for use in other scripts
module.exports = { FrontendPenetrationTest };

// Run if called directly
if (require.main === module) {
    async function main() {
        const pentest = new FrontendPenetrationTest();
        await pentest.initialize();
        await pentest.runAllTests();
    }
    
    main()
        .then(() => process.exit(0))
        .catch((error) => {
            console.error(error);
            process.exit(1);
        });
}
